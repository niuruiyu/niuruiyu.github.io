{"meta":{"title":"happyhappyniuniu's blog","subtitle":"","description":"","author":"niuruiyu","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2024-11-15T11:34:41.000Z","updated":"2024-11-16T07:36:53.081Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2024-11-15T11:34:06.000Z","updated":"2024-11-15T11:34:06.290Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2024-11-15T11:32:34.000Z","updated":"2024-11-15T11:32:34.083Z","comments":true,"path":"tags/随笔/index.html","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/index.html","excerpt":"","text":""}],"posts":[{"title":"2025.2.17学习笔记《递归》","slug":"my-post5","date":"2025-02-17T09:34:40.000Z","updated":"2025-02-17T09:38:02.771Z","comments":true,"path":"2025/02/17/my-post5/","permalink":"http://example.com/2025/02/17/my-post5/","excerpt":"","text":"递归&#x2F;&#x2F;eee我先放在这里明天再学嘻嘻嘻","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"2025.2.17学习笔记（二）《数据结构》《模拟和思维》","slug":"my-post4","date":"2025-02-17T05:53:03.000Z","updated":"2025-02-17T09:38:49.872Z","comments":true,"path":"2025/02/17/my-post4/","permalink":"http://example.com/2025/02/17/my-post4/","excerpt":"数据结构常见数据结构数组，链表（用的不多），栈，队列（bfs）树，图，散列表（hash）数据结构决定了时间复杂度，空间复杂度以及优化方向。这些之前在课程中都学过，这里不进行赘述。重点应该放到这些数据结构如何进行功能实现上。","text":"数据结构常见数据结构数组，链表（用的不多），栈，队列（bfs）树，图，散列表（hash）数据结构决定了时间复杂度，空间复杂度以及优化方向。这些之前在课程中都学过，这里不进行赘述。重点应该放到这些数据结构如何进行功能实现上。 模拟和思维逆向思维：搜索问题，动态规划问题，构造算法 例题1：青蛙跳台阶一只青蛙可以跳上一级台阶，也可以跳上两级台阶，求青蛙跳上n级台阶一共有多少种不同的跳法？这个问题是动态规划的简单问题，也是逆向思维的一个反映。代码也很简单： 1234567891011121314#include&lt;bits/stdc++.h&gt;using namespace std;const int num=1e6;long long dp[num]=&#123;0&#125;;int main()&#123; int n; cin&gt;&gt;n; dp[1]=1; dp[2]=2; for(int i=3;i&lt;=n;i++)&#123; dp[i]=dp[i-1]+dp[i-2];//函数 &#125; cout&lt;&lt;dp[n]&lt;&lt;endl;&#125; 逆向思维的小题目：逆序对计数（正序对计数），数字缺失，非重复元素前两个都很简单，非重复元素就是说：一个数组中只有一个元素出现奇数次，其余数字都出现了偶数次，问奇数次的元素？那就可以直接异或操作，因为任何数字和自己异或都为0，0和任何数字异或都是任何数字本身。 抽象与具体化两数之和给定一个整数数组和一个目标和，找出数组中和为目标值的两个数.可以用双重遍历，但是很明显时间复杂度太高那么优化方法可以是，先确定一个数组中的数字，判断我们需要的另一个数字是否在数组中。或者是可以先把数组排序，然后搞下标。 有效的括号判定一个字符串的括号是否都匹配上。用栈的数据结构，匹配是否弹出 贪心思维在求解过程中，每一步都采取当下最优的选择，从而导致最终结果最优。那么我需要证明的是我的局部最优可以导致整体最优。所以我需要判定改题目能否使用贪心算法。 例题1：兑换硬币给定一组硬币和一个总金额，要求用最少的硬币凑成这个金额。假设硬币面额位{1，5，10，20，50}，要凑成63元，贪心算法会选择一个50，一个10，三个1来凑成63，这也是最优解那用贪心算法来算： 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int arr[5]=&#123;50,20,10,5,1&#125;; int b[5]=&#123;0&#125;; int n; cin&gt;&gt;n; int num=0; for(int i=0;i&lt;5;i++)&#123; if(n&gt;=arr[i])&#123; b[i]=n/arr[i]; num=num+n/arr[i]; n=n%arr[i]; &#125; &#125; cout&lt;&lt;num&lt;&lt;endl; for(int i=0;i&lt;5;i++)&#123; cout&lt;&lt;arr[i]&lt;&lt;&quot;元：&quot;&lt;&lt;b[i]&lt;&lt;&quot;张&quot;&lt;&lt;endl; &#125;&#125; 但是思考局部的最优能否导向整体最优？回顾一下刚刚贪心算法的前提，是我们默认了当我们需要凑的钱越多，索要的钱币总数就越多，但是事实是：如果我需要凑五块钱，我只需要一张五元，但是如果我要凑三块钱，我就需要三张一元，这明显和我们的默认不符合，所以上面的贪心算法是错的。那这道题该怎么解决？可以用动态规划，其实我感觉所有的这种前一步影响后一步的题都有一点动态规划的思维。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"2025.2.17学习笔记（一）《暴力》","slug":"my-third-post","date":"2025-02-17T02:59:30.000Z","updated":"2025-02-17T05:50:55.199Z","comments":true,"path":"2025/02/17/my-third-post/","permalink":"http://example.com/2025/02/17/my-third-post/","excerpt":"又放了很久，今天是看网课进行学习， 这是第一篇内容是暴力解题填空题：前四道题，编程题：前三道题考点：语法和简单算法，字符串处理，递归入门，排序与查找，搜索算法基础（bfs，dfs），动态规划初步，暴力求解和分治策略（很多题可以直接用暴力得到分数）stl，vector，set基础，复杂递归问题，高级排序算法，分治和二分策略，dfs和bfs解决图论问题，动态规划，背包问题读题：看清关键信息，看清数据范围，便于选择具体的算法，输入输出格式思考：先思考再写代码下面是具体的学习过程","text":"又放了很久，今天是看网课进行学习， 这是第一篇内容是暴力解题填空题：前四道题，编程题：前三道题考点：语法和简单算法，字符串处理，递归入门，排序与查找，搜索算法基础（bfs，dfs），动态规划初步，暴力求解和分治策略（很多题可以直接用暴力得到分数）stl，vector，set基础，复杂递归问题，高级排序算法，分治和二分策略，dfs和bfs解决图论问题，动态规划，背包问题读题：看清关键信息，看清数据范围，便于选择具体的算法，输入输出格式思考：先思考再写代码下面是具体的学习过程 高频考点与暴力解题高频考点基础的数据结构（如数组，链表，栈，队列，树，图）基础算法（sort，二分，递归）搜索（深度搜索，光度搜索）动态规划（复杂问题变成简单子问题） 暴力解题通过穷举所有的情况步骤：确定范围，找出条件，明确输出，暴力枚举好实现，但是效率很低，填空题可以这么写，编程题可能会拿一定的分数 例题1：年龄问题：某人年龄的三次方是一个四位数，四次方是一个六位数，这十个数字从0到9各有一个，问这个人多少岁？（问题是被我简化后的，原题有情景）这道题我自己写了代码，可以得出正确答案是18 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;int ss;bool flag=1;int main()&#123;//先确定暴力的范围，年龄一定是10到30岁 int x=10; for(x;x&lt;30;x++)&#123; int num[10]=&#123;0&#125;; if(x*x*x&lt;10000&amp;&amp;x*x*x&gt;999&amp;&amp;x*x*x*x&lt;1000000&amp;&amp;x*x*x*x&gt;99999)//第一个条件 &#123; long long a=x*x*x; long long b=a*x*10000; long long c=b+a;//用longlong存比较保险 while(c)&#123; num[c%10]++; c/=10;&#125; for(int i=0;i&lt;10;i++)&#123; if(num[i]&gt;1||num[i]==0)&#123; flag=0;&#125;&#125; if(flag==1)&#123;ss=x; &#125;//用这么多实现判断是否从0到9都有 &#125; &#125;cout&lt;&lt;ss&lt;&lt;endl;&#125; 视频里面的题解用了字符串的内容，时间复杂度会比较低，但其实差不多,因为只是小题目 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;bool isUnique(long long n1,long long n2)&#123; string s=to_string(n1) + to_string(n2); if(s.length()!=10)return false; sort(s.begin(),s.end()); for(int i=0;i&lt;10;i++)&#123; if(s[i]!=&#x27;0&#x27;+i)return false; &#125; return true;&#125; int main()&#123; int x=10; for(x;x&lt;30;x++)&#123; long long cube=x*x*x; long long forth=x*x*x*x; if(cube&gt;=1000&amp;&amp;cube&lt;10000&amp;&amp;forth&gt;=100000&amp;&amp;forth&lt;1000000)&#123; if(isUnique(cube,forth))&#123;//这里写了一个函数 cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;cube&lt;&lt;&quot; &quot;&lt;&lt;forth&lt;&lt;endl;//把三次和四次也输出是为了验证的出来的答案对不对 &#125; &#125; &#125;&#125; 例题2：继续猜年龄小明的两个妹妹，年龄之积是年龄之和的6倍，年龄只差不超过8岁，不是双胞胎，问两个人的年龄?这道题也是我自己写了代码，答案是对的，时间复杂度是n^2 1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;bool istrue(int x,int y)&#123; if(x*y==6*(x+y)&amp;&amp;x!=y&amp;&amp;fabs(x-y)&lt;=8)&#123; return true; &#125; return false;&#125;int main()&#123; int x,y; for(x=5;x&lt;=40;x++)&#123; for(y=5;y&lt;=40;y++)&#123; if(istrue(x,y)) cout&lt;&lt;x&lt;&lt;&#x27; &#x27;&lt;&lt;y&lt;&lt;endl;//输出有两个10 15和15 10 &#125; &#125;&#125; 视频的代码和我一样，区别是我写了函数，视频没有而已。 例题3：门牌制作从1到2020的门牌，一共需要多少个2？这道题之前做过，我的代码也很简单,最后答案是624 123456789101112#include&lt;bits/stdc++.h&gt;using namespace std;int num[10]=&#123;0&#125;;int main()&#123; for(int i=1;i&lt;=2020;i++)&#123; int a=i;//也可以用string库，用to_string也很简单 while(a)&#123; num[a%10]++; a/=10; &#125; &#125;cout&lt;&lt;num[2]&lt;&lt;endl;&#125; 例题4:国庆星期几（数日期的题目）1949年国庆节（10月1日）是星期六，2012年的国庆节是星期一，问从建国到2012年国庆，有几次国庆是星期日？其实数日期的题目一直是我的短板，还有一道题做了很久都不会，后面去写。范围小的话可以看电脑的日历一个一个去数hhhhh涉及星期题可以用python，但是我不会哈哈哈哈c++需要去算平年闰年但是也还算简单（学了之后），就直接暴力 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;using namespace std;int month[13]=&#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;;//月份表 bool runnian(int year)&#123; if(year%4==0&amp;&amp;year%100!=0)return true; if(year%400==0)return true; return false;&#125; int sum=0;int main()&#123; int day=1; int year=1949; int week=6; int mon=10;//初始化 for(mon=10;mon&lt;=12;mon++)&#123; for(day;day&lt;=month[mon];day++)&#123; if(week==8)&#123; week=1; &#125; week++; &#125; &#125;//先算出来1949年 12月31号是星期几 year++; week++; //然后就是1950年一月一日是星期几 //接下来就开始整年整年遍历 for(year;year&lt;=2012;year++)&#123; if(runnian(year))&#123; month[2]=29; &#125; else&#123; month[2]=28; &#125;//闰年平年的判断 for(mon=1;mon&lt;=12;mon++)&#123; for(day=1;day&lt;=month[mon];day++)&#123; if(week==8)week=1;//没有星期八 if(mon==10&amp;&amp;day==1&amp;&amp;week==7)&#123; sum++;//符合条件 &#125; week++;//别忘了。 &#125; &#125; &#125;cout&lt;&lt;sum&lt;&lt;endl;//答案是9 &#125; 例题五：还是数日期小兰每天跑一千米，但是如果当天是周一或一号，要跑两千米，（同时是周一或一号也是两千米），问从2000年1月1日周六到2020年10月1日周四（包含）一共跑了多少千米？答案是8879 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;int months[13]=&#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;;int sum=0;bool runnian(int year)&#123; if(year%4==0&amp;&amp;year%100!=0)return true; if(year%400==0)return true; return false;&#125;int main()&#123; int year=2000; int month=1; int day=1; int week=6;//初始值 for(year;year&lt;=2020;year++)&#123;//这个直接就是从1月1号开始的所以不用单独算一年剩下的时间 if(runnian(year))months[2]=29; else months[2]=28; for(month=1;month&lt;=12;month++)&#123; for(day=1;day&lt;=months[month];day++)&#123; if(week==8)week=1; if(day==1||week==1)sum+=2; else sum+=1;//什么时候跑一千米，什么时候跑两千米 if(year==2020&amp;&amp;month==10&amp;&amp;day==1)&#123; cout&lt;&lt;sum&lt;&lt;endl; return 0;//到2020年10月1日廷停止 &#125; week++;//别忘了 &#125; &#125; &#125;&#125; 那么这一章节在这里结束","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"2025.2.9学习笔记","slug":"my-second-blog","date":"2025-02-09T15:22:48.000Z","updated":"2025-02-09T16:43:43.668Z","comments":true,"path":"2025/02/09/my-second-blog/","permalink":"http://example.com/2025/02/09/my-second-blog/","excerpt":"前三天才开始学习，今天是第三天，这三天也只是进行了算法入门。就是刷题的同时复习算法。（这里进行一个复习（展开可以看全部","text":"前三天才开始学习，今天是第三天，这三天也只是进行了算法入门。就是刷题的同时复习算法。（这里进行一个复习（展开可以看全部 1.bst算法：对应的题目是走迷宫找最短的路程，bst有点像剥洋葱，但是一边剥里面一层一层还在生成。2.动态规划里面的0-1背包，数字三角形；动态规划的重点在于dp数组的构建and状态转移方程的构建dp数组就直接看有几个限制条件，（像是背包是两个限制条件：容量和价格，三角形：行和列，所以这两个都是二维数组）状态转移方程就是递推公式啦！0-1背包：dp[i][j]&#x3D;max(dp[i-1][j],dp[i-1][j-weight[i]]+price[i]);就是拿不拿第i个物品数字三角形:dp[i][j]&#x3D;value[i][j]+max(dp[i-1][j],dp[i-1][j-1]);3.两种最短路径问题的算法（1）floyed算法：（近似于动态规划，可以用于无向图时间复杂度比较高，因为有三个for循环步骤：初始化-&gt;算法-&gt;输出；(2)dijkstra算法:(这个学了好久，自己推算还挺简单，但是写代码好麻烦TAT)步骤：定义结构体-&gt;创建存储-&gt;算法里面用的比较特殊的数据结构是优先队列priority_queue用一个数组存储到达指定边的最短距离，用vector[],或者双重vector来存储边具体代码明天还要再打一遍，这里就不写了4.差分，这个简单，经常用于对数组元素连续多次改变步骤：创建差分数组-&gt;初始化差分数组-&gt;区间端点修改-&gt;还原结果5.计算一个数字的任意次方根pow(n,1&#x2F;3):n的立方根还有：sqrt(n),cbrt(n)还有两种方法，这两种方法不单单可以求方根，还可以求方程的解（1）牛顿迭代法（2）二分法两个都是不断缩小范围逼近真正地根，本质上都是求预测值步骤也基本相同：设定精度-&gt;设定初始值-&gt;牛顿迭代法（公式），二分法（二分）-&gt;输出6.并查集这个也很简单：初始化（每个元素自己一个集合）-&gt;路径压缩（也就是find（parent））-&gt;合并（parent不同时，让parent相同）-&gt;操作输出 上面只是简单写了一下思路，因为时间太晚了，今天也没学多少东西，但是经常联系真的很有效！！！！","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"happyhappyniuniu's first blog!!!","slug":"my-first-blog","date":"2024-11-16T05:44:12.000Z","updated":"2025-02-09T16:43:23.096Z","comments":true,"path":"2024/11/16/my-first-blog/","permalink":"http://example.com/2024/11/16/my-first-blog/","excerpt":"","text":"hello！这是第一篇我的blog，只是用来测试一下怎么发。 拜拜！","categories":[{"name":"测试","slug":"测试","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2024-11-15T08:02:07.962Z","updated":"2024-11-15T08:02:07.962Z","comments":true,"path":"2024/11/15/hello-world/","permalink":"http://example.com/2024/11/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"测试","slug":"测试","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[]}