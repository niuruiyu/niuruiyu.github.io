{"meta":{"title":"happyhappyniuniu's blog","subtitle":"","description":"","author":"niuruiyu","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2024-11-15T11:34:41.000Z","updated":"2024-11-16T07:36:53.081Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2024-11-15T11:34:06.000Z","updated":"2024-11-15T11:34:06.290Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2024-11-15T11:32:34.000Z","updated":"2024-11-15T11:32:34.083Z","comments":true,"path":"tags/随笔/index.html","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/index.html","excerpt":"","text":""}],"posts":[{"title":"2025.2.23学习笔记《排序》","slug":"my-post6","date":"2025-02-23T05:09:28.000Z","updated":"2025-02-23T10:53:15.790Z","comments":true,"path":"2025/02/23/my-post6/","permalink":"http://example.com/2025/02/23/my-post6/","excerpt":"排序算法全解析这里主要是sort函数以及其重载，快排（用的很少），归并排序","text":"排序算法全解析这里主要是sort函数以及其重载，快排（用的很少），归并排序 sort()函数函数库：algorithm 默认情况下：sort函数使用元素的&lt;运算符进行升序排序1234567891011121314151617181920//vectorvector&lt;int&gt; vec=&#123;5,4,3,2,1&#125;;sort(vec.begin(),vec.end());//对vector进行升序排序for(int num:vec)&#123; cout&lt;&lt;num&lt;&lt;&quot; &quot;;&#125; //输出是1 2 3 4 5 cout&lt;&lt;endl;//数组 int arr[5]=&#123;5,4,3,2,1&#125;;sort(arr,arr+5);//对 array及逆行排序，要注意的是左闭右开的区间 for(int i=0;i&lt;5;i++)&#123; cout&lt;&lt;arr[i]&lt;&lt;&#x27; &#x27;;&#125; //输出：1，2，3，4，5 cout&lt;&lt;endl;//字符 char a[5]=&#123;&#x27;k&#x27;,&#x27;l&#x27;,&#x27;a&#x27;,&#x27;f&#x27;,&#x27;b&#x27;&#125;;sort(a,a+5);//对字符按照字典序进行排序for(int i=0;i&lt;5;i++)&#123; cout&lt;&lt;a[i]&lt;&lt;&#x27; &#x27;;&#125; cout&lt;&lt;endl;//输出：a b f k l 自定义比较函数sort前两个参数传入起点地址和终点地址，第三个参数传入自定义比较函数 降序排序1234567891011121314#include&lt;bits/stdc++.h&gt;#include&lt;algorithm&gt;using namespace std;//自定义一个降序的比较函数bool cmp(int a,int b)&#123; return a&gt;b;//降序比较 &#125; int main()&#123; vector&lt;int&gt;vec=&#123;1,2,3,4,5&#125;; sort(vec.begin(),vec.end(),cmp); for(int num:vec)&#123; cout&lt;&lt;num&lt;&lt;&#x27; &#x27;; &#125; cout&lt;&lt;endl;//输出：5 4 3 2 1 &#125; 上面的函数中：如果cmp return出来的是1，那就按照这个情况进行排序 结构体排序例如对学生这个结构体进行排序，根据成绩对他们进行降序排序 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;#include&lt;algorithm&gt;using namespace std;struct student&#123; string name; int score; student()&#123; &#125; student(string a,int b)&#123; name=a; score=b; &#125;&#125;; bool cmp_student(student a,student b)&#123; return a.score&gt;b.score;//就是按照成绩降序排序 &#125;int main()&#123; vector&lt;student&gt;vec; student a(&quot;aa&quot;,98); student b(&quot;bb&quot;,99); student c(&quot;cc&quot;,100); vec.push_back(a); vec.push_back(b); vec.push_back(c); sort(vec.begin(),vec.end(),cmp_student); for(student stu:vec)&#123; cout&lt;&lt;stu.name&lt;&lt;&quot;:&quot;&lt;&lt;stu.score&lt;&lt;endl; &#125; &#125; 同样可以更复杂一点，对抑制四门成绩的学生根据平均成绩进行降序排序那么对应地结构体和函数应该是 1234567891011121314151617struct student&#123; string name; int scores[4]; student(string a,int b,int c,int d,int e)&#123; name=a; scores[0]=b; scores[1]=c; scores[2]=d; scores[3]=e; &#125;&#125;;bool cmp_average(student a,student b)&#123; double average_a,average_b; average_a=double((a.scores[0]+a.scores[1]+a.scores[2]+a.scores[3])/4); average_b=double((b.scores[0]+b.scores[1]+b.scores[2]+b.scores[3])/4); return average_a&gt;average_b;&#125; 当然还有更复杂的情况，对这些学生进行排序名，总分高的靠前，总分一样则比较语文，语文一样则比较数学，数学一样就比较英语，英语一样就比科学 123456789101112131415161718192021222324252627282930struct student&#123; string name; int scores[4]; int sum; student(string a,int b,int c,int d,int e)&#123; name=a; scores[0]=b; scores[1]=c; scores[2]=d; scores[3]=e; sum=b+d+c+e; &#125;&#125;;bool cmp(student a,student b)&#123; if(a.sum!=b.sum)return a.sum&gt;b.sum; else&#123; if(a.scores[0]!=b.scores[0])return a.scores[0]&gt;b.scores[0]; else&#123; if(a.scores[1]!=b.scores[1])return a.scores[1]&gt;b.scores[1]; else&#123; if(a.scores[2]!=b.scores[2]) return a.scores[2]&gt;b.scores[2]; else&#123; return a.scores[3]&gt;b.scores[3]; &#125; &#125; &#125; &#125; &#125;&#125; 本质上和前面的逻辑都是一样的，就是加了几个ifelse语句 快速排序红红火火恍恍惚惚期末的时候手抄了好几遍代码，到头来还是没记住这里po出来快排实现的一个模板 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;const int num=1e6;int n;int q[num]=&#123;0&#125;;void quicksort(int l,int r)&#123; if(l==r)return; int x=q[(l+r)&gt;&gt;1];//就是最中间的数字，只不过用的更有效率的位运算 int i=l-1; int j=r+1; while(i&lt;j)&#123; do i++;while(q[i]&lt;x); do j--;while(q[j]&gt;x); if(i&lt;j) swap(q[i],q[j]); &#125; quicksort(l,j);//到这里i=j quicksort(j+1,r);&#125;int main()&#123; cin&gt;&gt;n; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;q[i]; &#125; quicksort(0,n-1); for(int i=0;i&lt;n;i++)cout&lt;&lt;q[i]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl;&#125; 归并排序基于分治思想，将已经有序的子序列合并，得到完全有序的序列核心是：将一维数组中前后相邻的两个有序序列归并为一个有序序列步骤：1.将数组递归地分成两个子数组2.将两个子数组进行归并排序3.将两个子数组合并为一个完整的数组 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;const int num=1e6+10;int arr[num],temp[num];int n;void mergesort(int l,int r)&#123; if(l&gt;=r)return;//或者l==r int mid=(l+r)&gt;&gt;1; mergesort(l,mid); mergesort(mid+1,r);//上面是第一步，递归地分成两个子数组 int k=0,i=l,j=mid+1; while(i&lt;=mid&amp;&amp;j&lt;=r)&#123; if(arr[i]&lt;=arr[j])temp[k++]=arr[i++]; else&#123;temp[k++]=arr[j++]; &#125; &#125; while(i&lt;=mid) temp[k++]=arr[i++]; while(j&lt;=r) temp[k++]=arr[j++]; for(i=l,j=0;i&lt;=r;i++,j++)&#123; arr[i]=temp[j]; &#125;&#125;int main()&#123; cin&gt;&gt;n; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;arr[i]; &#125; mergesort(0,n-1); for(int i=0;i&lt;n;i++)&#123; cout&lt;&lt;arr[i]&lt;&lt;&quot; &quot;; &#125;cout&lt;&lt;endl;&#125; 归并排序应用1：逆序对的数量123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;const int num=1e6+10;int n;int sum=0;int arr[num],temp[num];int merge(int l,int r)&#123;if(l&gt;=r)return 0;int mid=(l+r)&gt;&gt;1;sum=merge(l,mid)+merge(mid+1,r);int i=l,j=mid+1,k=0;while(i&lt;=mid&amp;&amp;j&lt;=r)&#123; if(arr[i]&lt;=arr[j])temp[k++]=arr[i++]; else&#123;//出现逆序对 temp[k++]=arr[j++]; sum+=mid-i+1;//也就是当前左边的数字的个数 &#125;&#125;while(i&lt;=mid)&#123; temp[k++]=arr[i++];&#125; while(j&lt;=r)&#123; temp[k++]=arr[j++];&#125; for(i=l,j=0;i&lt;=r;i++,j++)&#123; arr[i]=temp[j];&#125;return sum;//别忘了 &#125;int main()&#123; cin&gt;&gt;n; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;arr[i]; &#125; cout&lt;&lt;merge(0,n-1)&lt;&lt;endl; &#125; 唯一改变的地方在于，函数的类型，又加了一个变量来存储","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"2025.2.22学习笔记《递归》","slug":"my-post5","date":"2025-02-22T09:34:40.000Z","updated":"2025-02-23T05:07:19.016Z","comments":true,"path":"2025/02/22/my-post5/","permalink":"http://example.com/2025/02/22/my-post5/","excerpt":"递归核心：解决一个更小规模的同类型问题（边界条件）递归函数一定要有终止条件设计函数的步骤：1.明确函数功能2.找到递归的结束条件，例如阶乘的结束条件是1的阶乘是1；3.找到递归关系，这个是最重要的当地贵的次数过多时，会出现栈溢出，所以要避免。","text":"递归核心：解决一个更小规模的同类型问题（边界条件）递归函数一定要有终止条件设计函数的步骤：1.明确函数功能2.找到递归的结束条件，例如阶乘的结束条件是1的阶乘是1；3.找到递归关系，这个是最重要的当地贵的次数过多时，会出现栈溢出，所以要避免。 例题1：计算阶乘这个是最简单的问题 12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;int jiecheng(int n)&#123; if(n==1)&#123; return 1; &#125; return n*jiecheng(n-1);&#125;int main()&#123; int n; cin&gt;&gt;n; cout&lt;&lt;jiecheng(n)&lt;&lt;endl;&#125; 例题2：最大公约数（gcd）最大公约数的计算方式：辗转相除法辗转相除法：吧两个大数字的最大公约数转化成两个小叔子的最大公因数gcd(a,b)&#x3D;gcd(b,a%b)，这个在信安数基里面学过，就是a&#x3D;q*b+c，那么(a,b)&#x3D;(b.c);关系可以找到，但是什么时候停止呢，那就是当b可以整除a，即a%b&#x3D;&#x3D;0时，b就是最大公因数那么我们可以找到递归关系gcd(a,b)&#x3D;gcd(a,a%b)且当b&#x3D;0时，返回a的值（这里的a，b其实最硬的是位置，不是实际的a，b这两个数字 123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;int gcd(int a,int b)&#123; if(b==0)&#123;return a;&#125;//结束递归 return gcd(b,a%b);//递归方程 &#125;int main()&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;gcd(a,b)&lt;&lt;endl;&#125; 例题3：FJ的字符串题目：A1&#x3D;”A”A2&#x3D;”ABA”A3&#x3D;”ABACABA”An&#x3D;An-1+char(“A”+n-1)+An-1这里直接告诉了递归的方程 12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;string fj(int n)&#123;if(n==1)&#123; return &quot;A&quot;;&#125;return fj(n-1)+char(&#x27;A&#x27;+n-1)+fj(n-1);&#125;int main()&#123; int n; cin&gt;&gt;n; cout&lt;&lt;fj(n)&lt;&lt;endl;&#125; 这里也用到一个很简单的string类的stl，+ 例题4：递归实现指数型枚举从1~n这n个整数中随机选取任意多个数字，输出所有可能的选择方案n&lt;&#x3D;15，由n的范围可知，可以直接用暴力（输出的每一行是一个方案，且同一行的数字必须升序排列，对于没有选择任何数字的方案，输出空行 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;void dfs(int index,int n,vector&lt;int&gt;current)&#123;//index代表当前数字，n代表一共多少个数字（最多能选几个数字），vector用于 if(index&gt;n)&#123;//全部判断完之后 for(int i=0;i&lt;current.size();i++)&#123; cout&lt;&lt;current[i]&lt;&lt;&quot; &quot;; &#125;//输出此次选择的所有数字 cout&lt;&lt;endl; return; &#125; //不选当前的数字 dfs(index+1,n,current);//直接判断下一个数字选不选 //选当前数字 current.push_back(index);//把index放到vector中 dfs(index+1,n,current); //再判断下一个数字选不选 &#125;int main()&#123; int n; cin&gt;&gt;n; vector&lt;int&gt;vec; dfs(1,n,vec);&#125; 上面的算法还是可以优化：还是上面的思路，每一个数字我们只有两种情况：选或不选，上面的代码是把所有选的数字放进容器中那我们可以直接创建一个状态数组，来标记，每一个数字选或不选 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;const int num=1e5;int n;int s[num]=&#123;0&#125;;//0代表还没有判断，1代表选进去，2代表不选 void dfs(int x)&#123; if(x&gt;n)&#123; for(int i=1;i&lt;=n;i++)&#123; if(s[i]==1)&#123; cout&lt;&lt;i&lt;&lt;&quot; &quot;; &#125; &#125;cout&lt;&lt;endl; return; &#125; //不选： s[x]=2; dfs(x+1); s[x]=0;//回溯时归零，这样只需要用一个状态数组服务于所有可能的情况。 //选择； s[x]=1; dfs(x+1); s[x]=0;//同上 &#125;int main()&#123; cin&gt;&gt;n; dfs(1); return 0;&#125; 例题5：递归实现排列型枚举把1-n这n个数字排成一排后随机打乱顺序，输出所有可能的次序。要求按照从小到大的顺序输出所有方案，每行1个。 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;const int num=1e5;int n;int s[num]=&#123;0&#125;;bool visited[num]=&#123;0&#125;;void dfs(int x)&#123; if(x&gt;n)&#123; for(int i=1;i&lt;=n;i++)&#123; cout&lt;&lt;s[i]&lt;&lt;&quot; &quot;;//全选完的话 &#125; cout&lt;&lt;endl; return ;//别忘了 &#125; for(int i=1;i&lt;=n;i++)&#123;//从1到n一个数字一个数字看 if(visited[i]==0)&#123;//如果没有被选过 //选到x位： s[x]=i; visited[i]=1; dfs(x+1); s[x]=0; visited[i]=0; //回溯 //不选到x位就继续for循环，不进行其他操作，一直到x位有人选 &#125; &#125; &#125;int main()&#123; cin&gt;&gt;n; dfs(1); //从第一个位置开始选 &#125; 例题6：递归实现组合型枚举从1到n随机选出m个数字，输出所有可能的选择方案按照从小到大的顺序输出所有方案，每行一个，同一行内的数字升序排列这里我思考，是不是可以直接用例题4的东西，因为例题4是直接把所有可能（没有m的限制）都列出来那么可以设置一个变量专门记录选择了多少个数字。&#x2F;&#x2F;失败了。。。。视频里面的做法：谁的那个了两个变量u和start，u代表选择了几个数字，start代表当前可选择的最小数字，因为题目要求从小到大走，那就很容易了。 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;const int num=1e5;int s[num]=&#123;0&#125;;int n,m;void dfs(int u,int start)&#123;if(u+n-start&lt;m) return ;//剪枝,就是如果大于start的所有数字的个数都凑不出m个了，那就没必要继续搜索if(u&gt;m)&#123; for(int i=1;i&lt;=m;i++)&#123; cout&lt;&lt;s[i]&lt;&lt;&quot; &quot;; &#125;cout&lt;&lt;endl; return ;&#125; for(int i=1;i&lt;=n;i++)&#123;s[u]=i;dfs(u+1,i+1);s[u]=0;//回溯&#125; &#125; int main()&#123; cin&gt;&gt;n&gt;&gt;m; dfs(1,1);&#125; 例题7：走方格二维平面上的点阵，从上到下依次是第1到第n行，从左到右依次是第1到m列，一个人站在第1行第1列，要走到第n行第m列，只能享有或者向下走，如果行号和列号都是偶数，那就不走到这一行中，问有多少种方案？这个递归的边界条件有三个：第一个是走到n，m这个点，那么我们用来记录方案的变量要自增第二个是当横纵坐标都为2的倍数，那么直接取消这个方案，也就是return第三个是当终点位于所在点的左上方，那么无论如何都不可能到达终点了，也直接return递归的内容时dfs(x+1,y);dfs(x,y+1); 解1：暴力递归123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;const int num=10;int a=0;int n;int m;void dfs(int x,int y)&#123;if(x&gt;n||y&gt;m)return;if(x%2==0&amp;&amp;y%2==0)return ;if(x==n&amp;&amp;y==m)a++;dfs(x+1,y);dfs(x,y+1); &#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; dfs(1,1); cout&lt;&lt;a&lt;&lt;endl;&#125; 但是上面的方法需要暴力的东西太多，需要探索所有可能的方案如何优化？也就是很多路都有重复的走法，和dp很像，思考能不能把重复的地方记录下来，然后继续探索新路径 解2：记忆化搜索拿一个数组来记录数值，和dp很像，但是dp是循环暴力这个是递归暴力 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;const int num=35;int n,m;long long mer[num][num];//记录 long long dfs(int x,int y)&#123; if(x&gt;n||y&gt;m||(x%2==0&amp;&amp;y%2==0))return 0;//边界条件1 if(x==n&amp;&amp;y==m)return 1;// 边界条件2 if(mer[x][y]!=-1) return mer[x][y];//从x，y走到终点的方案数量，这样就不用再去递归。 long long ans=dfs(x,y+1)+dfs(x+1,y);//但是如果没有加算过该点，那就进行递归，递归的方程为，在该点的方案=右边一点的方案—+下边一点的方案 return mer[x][y]=ans;//存入数组 &#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; memset(mer,-1,sizeof(mer));//把mer里面所有的值都初始化为-1 //这个函数只适用于一组测试，会比for的初始化更有效率，但是如果是多组测试的话就不要用这个了 cout&lt;&lt;dfs(1,1)&lt;&lt;endl; &#125; 解3：动态规划状态转移方程就是dp[x][y]&#x3D;dp[x-1][y]+dp[x][y-1]初始值dp[1][1]&#x3D;0;dp[1][2]&#x3D;1;dp[2][1]&#x3D;1;但是要注意把有些情况排除掉下面是我的代码，感觉有点不太对 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;const int num=35;int n,m;long long dp[num][num]=&#123;0&#125;;//记录 int main()&#123; cin&gt;&gt;n&gt;&gt;m; dp[1][1]=0;//初始值 for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; if(i%2==0&amp;&amp;j%2==0)dp[i][j]=0;//2的情况 //由于for循环中已经限制了ij的范围，所以不用考虑终点在左边和上边的情况 else&#123; if((i==1&amp;&amp;j==2)||(i==2&amp;&amp;j==1))&#123;dp[i][j]=1; continue; &#125;//这里也是初始值，但是如果在for循环前面设定，状态转移方程会把它变成零 //可能是我的状态转移方程有问题 dp[i][j]=dp[i-1][j]+dp[i][j-1];//逻辑上是这样的 &#125; &#125; &#125; cout&lt;&lt;dp[n][m]&lt;&lt;endl;//直接输出 &#125; 找到问题：初始值的dp[1][1]应该设为1；其余均为0；但是我觉得其实有歧义，所以上面的代码也算对两个的区别在于求位于11的方案时答案不同，但是不妨碍 123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;const int num=35;int n,m;long long dp[num][num]=&#123;0&#125;;//记录 int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; if(i==1&amp;&amp;j==1)&#123;dp[i][j]=1; &#125; else&#123; if(i%2==1||j%2==1)&#123;dp[i][j]=dp[i-1][j]+dp[i][j-1]; &#125; &#125; &#125;&#125; cout&lt;&lt;dp[n][m]&lt;&lt;endl;//直接输出 &#125; 那么在这里进行一点动态规划的总结： 动态规划小tips1.确定dp数组的含义，每一个空间代表什么2.思考转移方向3.初始化动态数组dp的第一行或第一列4.写状态转移方程，还要注意边界条件和特殊情况的处理5.进行处理，一般用循环结构for进行状态转移6.根据问题需求，返回dp数组的某个值","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"2025.2.17学习笔记（二）《数据结构》《模拟和思维》","slug":"my-post4","date":"2025-02-17T05:53:03.000Z","updated":"2025-02-17T09:38:49.872Z","comments":true,"path":"2025/02/17/my-post4/","permalink":"http://example.com/2025/02/17/my-post4/","excerpt":"数据结构常见数据结构数组，链表（用的不多），栈，队列（bfs）树，图，散列表（hash）数据结构决定了时间复杂度，空间复杂度以及优化方向。这些之前在课程中都学过，这里不进行赘述。重点应该放到这些数据结构如何进行功能实现上。","text":"数据结构常见数据结构数组，链表（用的不多），栈，队列（bfs）树，图，散列表（hash）数据结构决定了时间复杂度，空间复杂度以及优化方向。这些之前在课程中都学过，这里不进行赘述。重点应该放到这些数据结构如何进行功能实现上。 模拟和思维逆向思维：搜索问题，动态规划问题，构造算法 例题1：青蛙跳台阶一只青蛙可以跳上一级台阶，也可以跳上两级台阶，求青蛙跳上n级台阶一共有多少种不同的跳法？这个问题是动态规划的简单问题，也是逆向思维的一个反映。代码也很简单： 1234567891011121314#include&lt;bits/stdc++.h&gt;using namespace std;const int num=1e6;long long dp[num]=&#123;0&#125;;int main()&#123; int n; cin&gt;&gt;n; dp[1]=1; dp[2]=2; for(int i=3;i&lt;=n;i++)&#123; dp[i]=dp[i-1]+dp[i-2];//函数 &#125; cout&lt;&lt;dp[n]&lt;&lt;endl;&#125; 逆向思维的小题目：逆序对计数（正序对计数），数字缺失，非重复元素前两个都很简单，非重复元素就是说：一个数组中只有一个元素出现奇数次，其余数字都出现了偶数次，问奇数次的元素？那就可以直接异或操作，因为任何数字和自己异或都为0，0和任何数字异或都是任何数字本身。 抽象与具体化两数之和给定一个整数数组和一个目标和，找出数组中和为目标值的两个数.可以用双重遍历，但是很明显时间复杂度太高那么优化方法可以是，先确定一个数组中的数字，判断我们需要的另一个数字是否在数组中。或者是可以先把数组排序，然后搞下标。 有效的括号判定一个字符串的括号是否都匹配上。用栈的数据结构，匹配是否弹出 贪心思维在求解过程中，每一步都采取当下最优的选择，从而导致最终结果最优。那么我需要证明的是我的局部最优可以导致整体最优。所以我需要判定改题目能否使用贪心算法。 例题1：兑换硬币给定一组硬币和一个总金额，要求用最少的硬币凑成这个金额。假设硬币面额位{1，5，10，20，50}，要凑成63元，贪心算法会选择一个50，一个10，三个1来凑成63，这也是最优解那用贪心算法来算： 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int arr[5]=&#123;50,20,10,5,1&#125;; int b[5]=&#123;0&#125;; int n; cin&gt;&gt;n; int num=0; for(int i=0;i&lt;5;i++)&#123; if(n&gt;=arr[i])&#123; b[i]=n/arr[i]; num=num+n/arr[i]; n=n%arr[i]; &#125; &#125; cout&lt;&lt;num&lt;&lt;endl; for(int i=0;i&lt;5;i++)&#123; cout&lt;&lt;arr[i]&lt;&lt;&quot;元：&quot;&lt;&lt;b[i]&lt;&lt;&quot;张&quot;&lt;&lt;endl; &#125;&#125; 但是思考局部的最优能否导向整体最优？回顾一下刚刚贪心算法的前提，是我们默认了当我们需要凑的钱越多，索要的钱币总数就越多，但是事实是：如果我需要凑五块钱，我只需要一张五元，但是如果我要凑三块钱，我就需要三张一元，这明显和我们的默认不符合，所以上面的贪心算法是错的。那这道题该怎么解决？可以用动态规划，其实我感觉所有的这种前一步影响后一步的题都有一点动态规划的思维。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"2025.2.17学习笔记（一）《暴力》","slug":"my-third-post","date":"2025-02-17T02:59:30.000Z","updated":"2025-02-17T05:50:55.199Z","comments":true,"path":"2025/02/17/my-third-post/","permalink":"http://example.com/2025/02/17/my-third-post/","excerpt":"又放了很久，今天是看网课进行学习， 这是第一篇内容是暴力解题填空题：前四道题，编程题：前三道题考点：语法和简单算法，字符串处理，递归入门，排序与查找，搜索算法基础（bfs，dfs），动态规划初步，暴力求解和分治策略（很多题可以直接用暴力得到分数）stl，vector，set基础，复杂递归问题，高级排序算法，分治和二分策略，dfs和bfs解决图论问题，动态规划，背包问题读题：看清关键信息，看清数据范围，便于选择具体的算法，输入输出格式思考：先思考再写代码下面是具体的学习过程","text":"又放了很久，今天是看网课进行学习， 这是第一篇内容是暴力解题填空题：前四道题，编程题：前三道题考点：语法和简单算法，字符串处理，递归入门，排序与查找，搜索算法基础（bfs，dfs），动态规划初步，暴力求解和分治策略（很多题可以直接用暴力得到分数）stl，vector，set基础，复杂递归问题，高级排序算法，分治和二分策略，dfs和bfs解决图论问题，动态规划，背包问题读题：看清关键信息，看清数据范围，便于选择具体的算法，输入输出格式思考：先思考再写代码下面是具体的学习过程 高频考点与暴力解题高频考点基础的数据结构（如数组，链表，栈，队列，树，图）基础算法（sort，二分，递归）搜索（深度搜索，光度搜索）动态规划（复杂问题变成简单子问题） 暴力解题通过穷举所有的情况步骤：确定范围，找出条件，明确输出，暴力枚举好实现，但是效率很低，填空题可以这么写，编程题可能会拿一定的分数 例题1：年龄问题：某人年龄的三次方是一个四位数，四次方是一个六位数，这十个数字从0到9各有一个，问这个人多少岁？（问题是被我简化后的，原题有情景）这道题我自己写了代码，可以得出正确答案是18 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;int ss;bool flag=1;int main()&#123;//先确定暴力的范围，年龄一定是10到30岁 int x=10; for(x;x&lt;30;x++)&#123; int num[10]=&#123;0&#125;; if(x*x*x&lt;10000&amp;&amp;x*x*x&gt;999&amp;&amp;x*x*x*x&lt;1000000&amp;&amp;x*x*x*x&gt;99999)//第一个条件 &#123; long long a=x*x*x; long long b=a*x*10000; long long c=b+a;//用longlong存比较保险 while(c)&#123; num[c%10]++; c/=10;&#125; for(int i=0;i&lt;10;i++)&#123; if(num[i]&gt;1||num[i]==0)&#123; flag=0;&#125;&#125; if(flag==1)&#123;ss=x; &#125;//用这么多实现判断是否从0到9都有 &#125; &#125;cout&lt;&lt;ss&lt;&lt;endl;&#125; 视频里面的题解用了字符串的内容，时间复杂度会比较低，但其实差不多,因为只是小题目 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;bool isUnique(long long n1,long long n2)&#123; string s=to_string(n1) + to_string(n2); if(s.length()!=10)return false; sort(s.begin(),s.end()); for(int i=0;i&lt;10;i++)&#123; if(s[i]!=&#x27;0&#x27;+i)return false; &#125; return true;&#125; int main()&#123; int x=10; for(x;x&lt;30;x++)&#123; long long cube=x*x*x; long long forth=x*x*x*x; if(cube&gt;=1000&amp;&amp;cube&lt;10000&amp;&amp;forth&gt;=100000&amp;&amp;forth&lt;1000000)&#123; if(isUnique(cube,forth))&#123;//这里写了一个函数 cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;cube&lt;&lt;&quot; &quot;&lt;&lt;forth&lt;&lt;endl;//把三次和四次也输出是为了验证的出来的答案对不对 &#125; &#125; &#125;&#125; 例题2：继续猜年龄小明的两个妹妹，年龄之积是年龄之和的6倍，年龄只差不超过8岁，不是双胞胎，问两个人的年龄?这道题也是我自己写了代码，答案是对的，时间复杂度是n^2 1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;bool istrue(int x,int y)&#123; if(x*y==6*(x+y)&amp;&amp;x!=y&amp;&amp;fabs(x-y)&lt;=8)&#123; return true; &#125; return false;&#125;int main()&#123; int x,y; for(x=5;x&lt;=40;x++)&#123; for(y=5;y&lt;=40;y++)&#123; if(istrue(x,y)) cout&lt;&lt;x&lt;&lt;&#x27; &#x27;&lt;&lt;y&lt;&lt;endl;//输出有两个10 15和15 10 &#125; &#125;&#125; 视频的代码和我一样，区别是我写了函数，视频没有而已。 例题3：门牌制作从1到2020的门牌，一共需要多少个2？这道题之前做过，我的代码也很简单,最后答案是624 123456789101112#include&lt;bits/stdc++.h&gt;using namespace std;int num[10]=&#123;0&#125;;int main()&#123; for(int i=1;i&lt;=2020;i++)&#123; int a=i;//也可以用string库，用to_string也很简单 while(a)&#123; num[a%10]++; a/=10; &#125; &#125;cout&lt;&lt;num[2]&lt;&lt;endl;&#125; 例题4:国庆星期几（数日期的题目）1949年国庆节（10月1日）是星期六，2012年的国庆节是星期一，问从建国到2012年国庆，有几次国庆是星期日？其实数日期的题目一直是我的短板，还有一道题做了很久都不会，后面去写。范围小的话可以看电脑的日历一个一个去数hhhhh涉及星期题可以用python，但是我不会哈哈哈哈c++需要去算平年闰年但是也还算简单（学了之后），就直接暴力 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;using namespace std;int month[13]=&#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;;//月份表 bool runnian(int year)&#123; if(year%4==0&amp;&amp;year%100!=0)return true; if(year%400==0)return true; return false;&#125; int sum=0;int main()&#123; int day=1; int year=1949; int week=6; int mon=10;//初始化 for(mon=10;mon&lt;=12;mon++)&#123; for(day;day&lt;=month[mon];day++)&#123; if(week==8)&#123; week=1; &#125; week++; &#125; &#125;//先算出来1949年 12月31号是星期几 year++; week++; //然后就是1950年一月一日是星期几 //接下来就开始整年整年遍历 for(year;year&lt;=2012;year++)&#123; if(runnian(year))&#123; month[2]=29; &#125; else&#123; month[2]=28; &#125;//闰年平年的判断 for(mon=1;mon&lt;=12;mon++)&#123; for(day=1;day&lt;=month[mon];day++)&#123; if(week==8)week=1;//没有星期八 if(mon==10&amp;&amp;day==1&amp;&amp;week==7)&#123; sum++;//符合条件 &#125; week++;//别忘了。 &#125; &#125; &#125;cout&lt;&lt;sum&lt;&lt;endl;//答案是9 &#125; 例题五：还是数日期小兰每天跑一千米，但是如果当天是周一或一号，要跑两千米，（同时是周一或一号也是两千米），问从2000年1月1日周六到2020年10月1日周四（包含）一共跑了多少千米？答案是8879 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;int months[13]=&#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;;int sum=0;bool runnian(int year)&#123; if(year%4==0&amp;&amp;year%100!=0)return true; if(year%400==0)return true; return false;&#125;int main()&#123; int year=2000; int month=1; int day=1; int week=6;//初始值 for(year;year&lt;=2020;year++)&#123;//这个直接就是从1月1号开始的所以不用单独算一年剩下的时间 if(runnian(year))months[2]=29; else months[2]=28; for(month=1;month&lt;=12;month++)&#123; for(day=1;day&lt;=months[month];day++)&#123; if(week==8)week=1; if(day==1||week==1)sum+=2; else sum+=1;//什么时候跑一千米，什么时候跑两千米 if(year==2020&amp;&amp;month==10&amp;&amp;day==1)&#123; cout&lt;&lt;sum&lt;&lt;endl; return 0;//到2020年10月1日廷停止 &#125; week++;//别忘了 &#125; &#125; &#125;&#125; 那么这一章节在这里结束","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"2025.2.9学习笔记","slug":"my-second-blog","date":"2025-02-09T15:22:48.000Z","updated":"2025-02-09T16:43:43.668Z","comments":true,"path":"2025/02/09/my-second-blog/","permalink":"http://example.com/2025/02/09/my-second-blog/","excerpt":"前三天才开始学习，今天是第三天，这三天也只是进行了算法入门。就是刷题的同时复习算法。（这里进行一个复习（展开可以看全部","text":"前三天才开始学习，今天是第三天，这三天也只是进行了算法入门。就是刷题的同时复习算法。（这里进行一个复习（展开可以看全部 1.bst算法：对应的题目是走迷宫找最短的路程，bst有点像剥洋葱，但是一边剥里面一层一层还在生成。2.动态规划里面的0-1背包，数字三角形；动态规划的重点在于dp数组的构建and状态转移方程的构建dp数组就直接看有几个限制条件，（像是背包是两个限制条件：容量和价格，三角形：行和列，所以这两个都是二维数组）状态转移方程就是递推公式啦！0-1背包：dp[i][j]&#x3D;max(dp[i-1][j],dp[i-1][j-weight[i]]+price[i]);就是拿不拿第i个物品数字三角形:dp[i][j]&#x3D;value[i][j]+max(dp[i-1][j],dp[i-1][j-1]);3.两种最短路径问题的算法（1）floyed算法：（近似于动态规划，可以用于无向图时间复杂度比较高，因为有三个for循环步骤：初始化-&gt;算法-&gt;输出；(2)dijkstra算法:(这个学了好久，自己推算还挺简单，但是写代码好麻烦TAT)步骤：定义结构体-&gt;创建存储-&gt;算法里面用的比较特殊的数据结构是优先队列priority_queue用一个数组存储到达指定边的最短距离，用vector[],或者双重vector来存储边具体代码明天还要再打一遍，这里就不写了4.差分，这个简单，经常用于对数组元素连续多次改变步骤：创建差分数组-&gt;初始化差分数组-&gt;区间端点修改-&gt;还原结果5.计算一个数字的任意次方根pow(n,1&#x2F;3):n的立方根还有：sqrt(n),cbrt(n)还有两种方法，这两种方法不单单可以求方根，还可以求方程的解（1）牛顿迭代法（2）二分法两个都是不断缩小范围逼近真正地根，本质上都是求预测值步骤也基本相同：设定精度-&gt;设定初始值-&gt;牛顿迭代法（公式），二分法（二分）-&gt;输出6.并查集这个也很简单：初始化（每个元素自己一个集合）-&gt;路径压缩（也就是find（parent））-&gt;合并（parent不同时，让parent相同）-&gt;操作输出 上面只是简单写了一下思路，因为时间太晚了，今天也没学多少东西，但是经常联系真的很有效！！！！","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"happyhappyniuniu's first blog!!!","slug":"my-first-blog","date":"2024-11-16T05:44:12.000Z","updated":"2025-02-09T16:43:23.096Z","comments":true,"path":"2024/11/16/my-first-blog/","permalink":"http://example.com/2024/11/16/my-first-blog/","excerpt":"","text":"hello！这是第一篇我的blog，只是用来测试一下怎么发。 拜拜！","categories":[{"name":"测试","slug":"测试","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2024-11-15T08:02:07.962Z","updated":"2024-11-15T08:02:07.962Z","comments":true,"path":"2024/11/15/hello-world/","permalink":"http://example.com/2024/11/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"测试","slug":"测试","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[]}